// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: measurement.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///
/// Copyright (C) 2021 Cyface GmbH - All Rights Reserved
///
/// Unauthorized copying of this file, via any medium is strictly prohibited
/// Proprietary and confidential

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// A message type which wraps all data collected between a "start" and a "stop" lifecycle event.
///
/// We are reserving field numbers 1-15 for high-frequent fields (> 10 Hz) that we might want to add later.
/// - The `reserved` definition is not used, as "field numbers cannot be used by future users"
///   see https://developers.google.com/protocol-buffers/docs/proto3#updating
/// - The following fields are not repeating: formatVersion, locationsRecords, accelerations/r./d., capturingLog
/// - The following fields are expected less than 10 Hz: events, images, videos
///
/// author Armin Schnabel
/// Version 1.0.0
struct De_Cyface_Protos_Model_Measurement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The API version of this `Measurement` message format. Messages with the same API-version are compatible.
  ///
  /// Using `32bit` as we expect the version to be and within the range of an `integer`.
  ///
  /// The value is encoded in the `uint` ProtoBuf format as we expect the version to be positive.
  /// Negative numbers are supported but encoded inefficiently in `uint` this data type, compared to `sint`.
  ///
  /// The current format API version is `2`.
  var formatVersion: UInt32 = 0

  ///
  /// Collection of geo-locations.
  ///
  /// We use a packed encoding here, so this is a non repeated field.
  var locationRecords: De_Cyface_Protos_Model_LocationRecords {
    get {return _locationRecords ?? De_Cyface_Protos_Model_LocationRecords()}
    set {_locationRecords = newValue}
  }
  /// Returns true if `locationRecords` has been explicitly set.
  var hasLocationRecords: Bool {return self._locationRecords != nil}
  /// Clears the value of `locationRecords`. Subsequent reads from it will return its default value.
  mutating func clearLocationRecords() {self._locationRecords = nil}

  ///
  /// Acceleration data stored during capturing.
  var accelerationsBinary: De_Cyface_Protos_Model_AccelerationsBinary {
    get {return _accelerationsBinary ?? De_Cyface_Protos_Model_AccelerationsBinary()}
    set {_accelerationsBinary = newValue}
  }
  /// Returns true if `accelerationsBinary` has been explicitly set.
  var hasAccelerationsBinary: Bool {return self._accelerationsBinary != nil}
  /// Clears the value of `accelerationsBinary`. Subsequent reads from it will return its default value.
  mutating func clearAccelerationsBinary() {self._accelerationsBinary = nil}

  ///
  /// Rotation data stored during capturing.
  var rotationsBinary: De_Cyface_Protos_Model_RotationsBinary {
    get {return _rotationsBinary ?? De_Cyface_Protos_Model_RotationsBinary()}
    set {_rotationsBinary = newValue}
  }
  /// Returns true if `rotationsBinary` has been explicitly set.
  var hasRotationsBinary: Bool {return self._rotationsBinary != nil}
  /// Clears the value of `rotationsBinary`. Subsequent reads from it will return its default value.
  mutating func clearRotationsBinary() {self._rotationsBinary = nil}

  ///
  /// Direction data stored during capturing.
  var directionsBinary: De_Cyface_Protos_Model_DirectionsBinary {
    get {return _directionsBinary ?? De_Cyface_Protos_Model_DirectionsBinary()}
    set {_directionsBinary = newValue}
  }
  /// Returns true if `directionsBinary` has been explicitly set.
  var hasDirectionsBinary: Bool {return self._directionsBinary != nil}
  /// Clears the value of `directionsBinary`. Subsequent reads from it will return its default value.
  mutating func clearDirectionsBinary() {self._directionsBinary = nil}

  ///
  /// Collection of events.
  ///
  /// We use `repeated` as we don't expect as many events as e.g. sensor points.
  /// If we decide to store high-frequent events later on we can use a field number < 16 which only requires 1 Byte.
  var events: [De_Cyface_Protos_Model_Event] = []

  ///
  /// The image files, optionally collected during a measurement. Usually FileType `JPG` (compressed) or `DNG` (raw).
  ///
  /// We expect a similar image rates of 1 Hz or less, so a 2-Byte field number was chosen.
  ///
  /// The image size is kilo- or megabytes and, thus, field number encoding size is only a small fraction so `repeated` was chosen.
  var images: [De_Cyface_Protos_Model_File] = []

  ///
  /// The video files, optionally collected during a measurement. Usually FileType `MP4`.
  ///
  /// When a measurement is paused and resumed, multiple video files are collected per measurement - thus, `repeated`.
  var videos: [De_Cyface_Protos_Model_File] = []

  ///
  /// Log file which is optionally captured during images capturing. Usually FileType `CSV`.
  var capturingLog: De_Cyface_Protos_Model_File {
    get {return _capturingLog ?? De_Cyface_Protos_Model_File()}
    set {_capturingLog = newValue}
  }
  /// Returns true if `capturingLog` has been explicitly set.
  var hasCapturingLog: Bool {return self._capturingLog != nil}
  /// Clears the value of `capturingLog`. Subsequent reads from it will return its default value.
  mutating func clearCapturingLog() {self._capturingLog = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _locationRecords: De_Cyface_Protos_Model_LocationRecords? = nil
  fileprivate var _accelerationsBinary: De_Cyface_Protos_Model_AccelerationsBinary? = nil
  fileprivate var _rotationsBinary: De_Cyface_Protos_Model_RotationsBinary? = nil
  fileprivate var _directionsBinary: De_Cyface_Protos_Model_DirectionsBinary? = nil
  fileprivate var _capturingLog: De_Cyface_Protos_Model_File? = nil
}

///
/// This is a modified version of the message `Measurement` which allows to inject bytes from sensor data.
/// This allows the Android SDK synchronization to merge the captured sensor data without parsing it.
///
/// The only change which was made is replacing the data type of the sensor data fields with `bytes`.
///
/// ATTENTION: Make sure this message is always compatible to the `Measurement` message!
struct De_Cyface_Protos_Model_MeasurementBytes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The current format of the binary format version is `2`
  var formatVersion: UInt32 = 0

  ///
  /// Collection of geo-locations.
  var locationRecords: De_Cyface_Protos_Model_LocationRecords {
    get {return _locationRecords ?? De_Cyface_Protos_Model_LocationRecords()}
    set {_locationRecords = newValue}
  }
  /// Returns true if `locationRecords` has been explicitly set.
  var hasLocationRecords: Bool {return self._locationRecords != nil}
  /// Clears the value of `locationRecords`. Subsequent reads from it will return its default value.
  mutating func clearLocationRecords() {self._locationRecords = nil}

  ///
  /// Acceleration data stored during capturing.
  var accelerationsBinary: Data = Data()

  ///
  /// Rotation data stored during capturing.
  var rotationsBinary: Data = Data()

  ///
  /// Direction data stored during capturing.
  var directionsBinary: Data = Data()

  ///
  /// Collection of events.
  var events: [De_Cyface_Protos_Model_Event] = []

  ///
  /// The image files are usually of FileType `JPG` (compressed) or `DNG` (raw).
  var images: [De_Cyface_Protos_Model_File] = []

  ///
  /// The video files are usually of FileType `MP4`.
  var videos: [De_Cyface_Protos_Model_File] = []

  ///
  /// This field allows to attach this file which is usually a of FileType `CSV`.
  var capturingLog: De_Cyface_Protos_Model_File {
    get {return _capturingLog ?? De_Cyface_Protos_Model_File()}
    set {_capturingLog = newValue}
  }
  /// Returns true if `capturingLog` has been explicitly set.
  var hasCapturingLog: Bool {return self._capturingLog != nil}
  /// Clears the value of `capturingLog`. Subsequent reads from it will return its default value.
  mutating func clearCapturingLog() {self._capturingLog = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _locationRecords: De_Cyface_Protos_Model_LocationRecords? = nil
  fileprivate var _capturingLog: De_Cyface_Protos_Model_File? = nil
}

///
/// A message type which wraps the `Accelerations` batches captured in a `cyfa` file of a measurement.
///
/// This allows to inject the bytes from a `cyfa` file on the client without parsing the data [DAT-642].
struct De_Cyface_Protos_Model_AccelerationsBinary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Collection of acceleration point batches.
  ///
  /// The sensor points are stored in batches to simplify the client code.
  var accelerations: [De_Cyface_Protos_Model_Accelerations] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// A message type which wraps the `Accelerations` batches captured in a `cyfa` file of a measurement.
///
/// This allows to inject the bytes from a `cyfa` file on the client without parsing the data [DAT-642].
struct De_Cyface_Protos_Model_RotationsBinary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Collection of rotation point batches.
  ///
  /// The sensor points are stored in batches to simplify the client code.
  var rotations: [De_Cyface_Protos_Model_Rotations] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// A message type which wraps the `Accelerations` batches captured in a `cyfa` file of a measurement.
///
/// This allows to inject the bytes from a `cyfa` file on the client without parsing the data [DAT-642].
struct De_Cyface_Protos_Model_DirectionsBinary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Collection of direction point batches.
  ///
  /// The sensor points are stored in batches to simplify the client code.
  var directions: [De_Cyface_Protos_Model_Directions] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// A message type which wraps all geo-locations captured for one measurement.
///
/// Each field contains the ordered list of that attribute for all points.
/// I.e. field1[4] and field2[4] belong to the same point.
///
/// Reason why we don't use `repeated LocationRecord` (and the same for sensor data):
/// - In proto3 repeated fields use the "packed" encoding by default.
///   A field with 0 elements is not appearing in the message.
///   A field with >0 elements and a "primitive numeric type" use a single key-value pair with "wire type 2(length-delimited)".
///   Fields with non-primitive types (like `LocationRecord` would be) encode the `key` for each repetition of `LocationRecord`.
///   Example: LR KV KV, LR KV ... with LR = field number of LocationRecord and KV is a key-value pair inside this record.
///   i.e.: LocationRecord{ts=1234567890123,lat=51012345,lon=13012345}, LocationRecord{ts=1000,lat=34,lon=54}
///   Bytes: 56-66 KiB (without/with elevations) for a measurement with 3600 Locations (and no sensor data)
/// - We use a more efficient way: One LR-entry with multiple primitive `packed` fields.
///   Example: LR K V V V V V K V V V V V, i.e. we only have to encode the type "LocationRecord" once not for each record.
///   i.e: LocationRecords { ts=[1234567890123,1000,1000], lat=[51012345,34,35], lon=[13012345,54,55]}
///   Bytes: 32-49 KiB (without/with elevations) for a measurement with 3600 Locations (and no sensor data)
/// - In this annotation each LR must have a ts/lat/lon/speed/accuracy or else this does not work.
///   Only for `elevation` we define a `Elevation` message type which can also have no value and would encoded: `E E KV` or `E KV E KV`
struct De_Cyface_Protos_Model_LocationRecords {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// A Unix timestamp in milliseconds, in the offset/diff format. E.g.: 1234567890123,1000,1000,1000.
  ///
  /// The offset/diff format encodes the data more efficiently, as the `varint` encoding is used.
  ///
  /// Using `64bit` as the first timestamp is absolute and in milliseconds since 1970 and, thus, not an `integer`.
  ///
  /// The value is encoded in the `uint` ProtoBuf format as we expect the timestamps to be in order (ascending).
  /// Negative numbers are supported but encoded inefficiently in `uint` this data type, compared to `sint`.
  var timestamp: [UInt64] = []

  ///
  /// The coordinate-part, in the offset/diff format. E.g.: 51.012345,51.012300 => 51_012345,-45
  ///
  /// The offset/diff format encodes the data more efficiently, as the `varint` encoding is used.
  ///
  /// Using `32bit` as the maximum value is the diff between -180 and +180 which is: 360_000_000 and within `integer` range.
  ///
  /// The value is encoded in the `sint` ProtoBuf format as the latitude can as likely decrease as increase (diff-format).
  /// Negative numbers are encoded more efficiently in this data type, compared to `uint`.
  var latitude: [Int32] = []

  ///
  /// The coordinate-part, in the offset/diff format. E.g.: 13.012300,13.012345 => 13_012300,45
  ///
  /// The offset/diff format encodes the data more efficiently, as the `varint` encoding is used.
  ///
  /// Using `32bit` as the maximum value is the diff between -90 and +90 which is: 180_000_000 and within `integer` range.
  ///
  /// The value is encoded in the `sint` ProtoBuf format as the longitude can as likely decrease as increase (diff-format).
  /// Negative numbers are encoded more efficiently in this data type, compared to `uint`.
  var longitude: [Int32] = []

  ///
  /// The elevations, in the same order as the other `repeated` `LocationRecords` fields.
  ///
  /// Using a complex type `Elevation` for elevations as we expect some elevations to be `null`. Due to the "collection"
  /// format of the `LocationRecords` we cannot use a `repeated sint32 elevation` field as this does not support `null` entries.
  ///
  /// Using a 1-byte field number (1-15) as this is a repeated complex field, i.e. these numbers are encoded for each elevation.
  var elevation: [De_Cyface_Protos_Model_LocationRecords.Elevation] = []

  ///
  /// Accuracy in cm (absolute value must be >= 0), in the offset/diff format. E.g.: 13.0m, 12.5m => 13_00cm, -50cm
  ///
  /// The offset/diff format encodes the data more efficiently, as the `varint` encoding is used.
  ///
  /// Using `32bit` i.e. we support a diff value up to ~2*10^9 cm which is ~ 20.000 km.
  ///
  /// The value is encoded in the `sint` ProtoBuf format as the longitude can as likely decrease as increase (diff-format).
  /// Negative numbers are encoded more efficiently in this data type, compared to `uint`.
  ///
  /// The likelihood of that accuracy to be correct is not stored as not all platforms provide this or provide this in different format.
  /// For some platform this is static, i.e. we can retrieve this information from the osVersion/osType field.
  var accuracy: [Int32] = []

  ///
  /// Speed in cm/s (absolute value should be >= 0), in the offset/diff format. E.g.: 11.0m/s, 10.5m/s => 11_00 cm/s, -50cm/s
  /// However, some platforms (Samsung?) recorded negative absolute speed values in the past. This is supported by the format.
  ///
  /// The offset/diff format encodes the data more efficiently, as the `varint` encoding is used.
  ///
  /// Using `32bit` i.e. we support a diff value up to ~2*10^9 cm/s which is ~ 20.000 km/s.
  /// As we capture the speed relative to the earth's rotation, we should be covering all manned aircraft, but not spacecrafts.
  ///
  /// The value is encoded in the `sint` ProtoBuf format as the longitude can as likely decrease as increase (diff-format).
  /// Negative numbers are encoded more efficiently in this data type, compared to `uint`.
  var speed: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// The elevation. If existent, the `value` field must be set. If not, the `is_null` field must be set to true.
  ///
  /// The encoding should look like the following:
  /// - E 1 48000 E 1 100 E 1 -50 (scenario where all locations have elevations)
  /// - E 1 48000 E 2 1   E 1 100 (scenario where some locations have elevations)
  /// - 0 bytes                   (scenario without elevations)
  struct Elevation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Elevation in cm above sea level, in the offset/diff format. E.g.: 480.0m, 481.0m, 480.5m => 480_00cm, 100cm, -50cm
    ///
    /// The offset/diff format encodes the data more efficiently, as the `varint` encoding is used.
    ///
    /// Using `32bit` i.e. we support a diff value up to ~2*10^9 cm which is ~ 20.000 km. The diff between mount everest
    /// and the dead sea is ~ [8848m;-414m] so we should be good when teleporting between dry and comfy places on earth for a while.
    ///
    /// The value is encoded in the `sint` ProtoBuf format as the longitude can as likely decrease as increase (diff-format).
    /// Negative numbers are encoded more efficiently in this data type, compared to `uint`.
    var value: Int32 = 0

    ///
    /// This field is only encoded if no `value` is set (i.e. elevation `is_null`).
    ///
    /// We cannot just have the optional "value" field as we can't differentiate between default value (0) and unset (0)
    var isNull: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

///
/// A message type which wraps a batch of acceleration points captured for one measurement.
///
/// Each field contains the ordered list of that attribute for all points.
/// I.e. field1[4] and field2[4] belong to the same point.
///
/// The first point is stored as absolute number, subsequent points in the offset-format to reduce the byte size.
///
/// Reference phone, Pixel 3a, contains this sensor: https://www.bosch-sensortec.com/products/motion-sensors/imus/bmi160/
/// - Bosch recommends the following sensor: https://www.bosch-sensortec.com/products/motion-sensors/imus/bmi270/
/// - the sensitivity and value ranges are the same [DAT-646]
/// - the sensitivity is 0.004790957 i.e. ~ 1/208.73 ... which is 1÷(16384 [from datasheet] ÷9,81 [g to m/s])×8 [8 bits per byte/digit]
/// - Thus, we choose a unit value of 0.001 m/s^2, i.e 1mm/s^2.
struct De_Cyface_Protos_Model_Accelerations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// A Unix timestamp in milliseconds, in the offset/diff format. E.g.: 1234567890123,1000,1000,1000.
  ///
  /// The offset/diff format encodes the data more efficiently, as the `varint` encoding is used.
  ///
  /// Using `64bit` as the first timestamp is absolute and in milliseconds since 1970 and, thus, not an `integer`.
  ///
  /// The value is encoded in the `uint` ProtoBuf format as we expect the timestamps to be in order (ascending).
  /// Negative numbers are supported but encoded inefficiently in `uint` this data type, compared to `sint`.
  var timestamp: [UInt64] = []

  ///
  /// Acceleration value of one axis in mm/s^2, in the offset/diff format. E.g.:
  /// Absolute numbers: -9, 359, -4_820 => Offset-format: -9, +359, -5_179
  ///
  /// The offset/diff format encodes the data more efficiently, as the `varint` encoding is used.
  ///
  /// Absolute values between +-16 m/s^2 are expected, i.e. +- 32_000 mm/s^2 diff.
  /// `32 bit` i.e. we support diffs up to ~2*10^9 mm/s^2 ~ 2.000 km/s^2. We should be fine here.
  ///
  /// Using `sint` as the one-axial-sensor-value can as likely decrease as increase - using the diff/offset format here.
  /// Negative numbers are encoded more efficiently in this data type, compared to `int32`.
  var x: [Int32] = []

  ///
  /// Acceleration value of one axis in mm/s^2, in the offset/diff format. E.g.:
  /// Absolute numbers: -9, 359, -4_820 => Offset-format: -9, +359, -5_179
  ///
  /// The offset/diff format encodes the data more efficiently, as the `varint` encoding is used.
  ///
  /// Absolute values between +-16 m/s^2 are expected, i.e. +- 32_000 mm/s^2 diff.
  /// `32 bit` i.e. we support diffs up to ~2*10^9 mm/s^2 ~ 2.000 km/s^2. We should be fine here.
  ///
  /// Using `sint` as the one-axial-sensor-value can as likely decrease as increase - using the diff/offset format here.
  /// Negative numbers are encoded more efficiently in this data type, compared to `int32`.
  var y: [Int32] = []

  ///
  /// Acceleration value of one axis in mm/s^2, in the offset/diff format. E.g.:
  /// Absolute numbers: -9, 359, -4_820 => Offset-format: -9, +359, -5_179
  ///
  /// The offset/diff format encodes the data more efficiently, as the `varint` encoding is used.
  ///
  /// Absolute values between +-16 m/s^2 are expected, i.e. +- 32_000 mm/s^2 diff.
  /// `32 bit` i.e. we support diffs up to ~2*10^9 mm/s^2 ~ 2.000 km/s^2. We should be fine here.
  ///
  /// Using `sint` as the one-axial-sensor-value can as likely decrease as increase - using the diff/offset format here.
  /// Negative numbers are encoded more efficiently in this data type, compared to `int32`.
  var z: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// A message type which wraps a batch of rotation points captured for one measurement.
///
/// Each field contains the ordered list of that attribute for all points.
/// I.e. field1[4] and field2[4] belong to the same point.
///
/// The first point is stored as absolute number, subsequent points in the offset-format to reduce the byte size.
///
/// Reference phone, Pixel 3a, contains this sensor: https://www.bosch-sensortec.com/products/motion-sensors/imus/bmi160/
/// - Bosch recommends the following sensor: https://www.bosch-sensortec.com/products/motion-sensors/imus/bmi270/
/// - the sensitivity and value ranges are the same [DAT-646]
/// - the sensitivity is 0.0010652635 rad/s. (e.g. the Tinkerforge IMU uses 1/16 °/s = 0.00109083078 rad/s)
/// - not sure how to get the sensitivity from the `262.4 LSB/°/s` from the data sheet, though
/// - Thus, we choose a unit value of 0.001 rad/s, i.e 1 rad/1000s (which would be 3.6 rad/h, but we don't use that unit).
struct De_Cyface_Protos_Model_Rotations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// A Unix timestamp in milliseconds, in the offset/diff format. E.g.: 1234567890123,1000,1000,1000.
  ///
  /// The offset/diff format encodes the data more efficiently, as the `varint` encoding is used.
  ///
  /// Using `64bit` as the first timestamp is absolute and in milliseconds since 1970 and, thus, not an `integer`.
  ///
  /// The value is encoded in the `uint` ProtoBuf format as we expect the timestamps to be in order (ascending).
  /// Negative numbers are supported but encoded inefficiently in `uint` this data type, compared to `sint`.
  var timestamp: [UInt64] = []

  ///
  /// Rotation value of one axis in rad/1000s, in the offset/diff format. E.g.:
  /// Absolute values: 83, -51, 4.367 => Offset-format: 83, -134, 4_418
  ///
  /// The offset/diff format encodes the data more efficiently, as the `varint` encoding is used.
  ///
  /// Absolute values between +(-?) 2000 degrees/s are expected, i.e. +- 2*34.906585 rad/s, i.e. +-69_814 rad/1000s diff.
  /// `32 bit` i.e. we support diffs up to ~2*10^9 rad/1000s ~ 2*10^6 rad/s. We should be fine here.
  ///
  /// Using `sint` as the one-axial-sensor-value can as likely decrease as increase - using the diff/offset format here.
  /// Negative numbers are encoded more efficiently in this data type, compared to `int32`.
  var x: [Int32] = []

  ///
  /// Rotation value of one axis in rad/1000s, in the offset/diff format. E.g.:
  /// Absolute values: 83, -51, 4.367 => Offset-format: 83, -134, 4_418
  ///
  /// The offset/diff format encodes the data more efficiently, as the `varint` encoding is used.
  ///
  /// Absolute values between +(-?) 2000 degrees/s are expected, i.e. +- 2*34.906585 rad/s, i.e. +-69_814 rad/1000s diff.
  /// `32 bit` i.e. we support diffs up to ~2*10^9 rad/1000s ~ 2*10^6 rad/s. We should be fine here.
  ///
  /// Using `sint` as the one-axial-sensor-value can as likely decrease as increase - using the diff/offset format here.
  /// Negative numbers are encoded more efficiently in this data type, compared to `int32`.
  var y: [Int32] = []

  ///
  /// Rotation value of one axis in rad/1000s, in the offset/diff format. E.g.:
  /// Absolute values: 83, -51, 4.367 => Offset-format: 83, -134, 4_418
  ///
  /// The offset/diff format encodes the data more efficiently, as the `varint` encoding is used.
  ///
  /// Absolute values between +(-?) 2000 degrees/s are expected, i.e. +- 2*34.906585 rad/s, i.e. +-69_814 rad/1000s diff.
  /// `32 bit` i.e. we support diffs up to ~2*10^9 rad/1000s ~ 2*10^6 rad/s. We should be fine here.
  ///
  /// Using `sint` as the one-axial-sensor-value can as likely decrease as increase - using the diff/offset format here.
  /// Negative numbers are encoded more efficiently in this data type, compared to `int32`.
  var z: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// A message type which wraps a batch of direction points captured for one measurement.
///
/// Each field contains the ordered list of that attribute for all points.
/// I.e. field1[4] and field2[4] belong to the same point.
///
/// The first point is stored as absolute number, subsequent points in the offset-format to reduce the byte size.
///
/// Reference phone, Pixel 3a, contains this sensor: akm, AK0991X Magnetometer, Version 20012 (no good data sheet found)
/// - Another phones use https://www.digikey.de/catalog/en/partgroup/ak09915/65408, with 1/16 resolution (same as e.g. Tinkerforge)
/// - the sensitivity is 0.15 µT. (e.g. Tinkerforge IMU uses 1/16 µT = 0.0625 µT)
/// - Thus, we choose a unit value of 0.01 µT, i.e 1 µT/100 (which would be 10 nT, but we don't use that unit).
struct De_Cyface_Protos_Model_Directions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// A Unix timestamp in milliseconds, in the offset/diff format. E.g.: 1234567890123,1000,1000,1000.
  ///
  /// The offset/diff format encodes the data more efficiently, as the `varint` encoding is used.
  ///
  /// Using `64bit` as the first timestamp is absolute and in milliseconds since 1970 and, thus, not an `integer`.
  ///
  /// The value is encoded in the `uint` ProtoBuf format as we expect the timestamps to be in order (ascending).
  /// Negative numbers are supported but encoded inefficiently in `uint` this data type, compared to `sint`.
  var timestamp: [UInt64] = []

  ///
  /// Direction value of one axis in µT/100, in the offset/diff format. E.g.:
  /// Absolute values: 67, -141, 42 => Offset-format: 67, -208, 183
  ///
  /// The offset/diff format encodes the data more efficiently, as the `varint` encoding is used.
  ///
  /// Absolute values between +- 4911.994 µT on Pixel 3a and +- 1300 µT on Tinkerforge are expected, i.e. +- 982_400 µT/100 diff.
  /// `32 bit` i.e. we support diffs up to ~2*10^9 µT/100 ~ 20 T so strong magnet as in the LHC/CERN are covered theoretically.
  ///
  /// The 10 nT (µT/100) unit does not cover you during travels between galaxies as you can't orientate by magnetic values
  /// due to the weak field there.
  ///
  /// Using `sint` as the one-axial-sensor-value can as likely decrease as increase - using the diff/offset format here.
  /// Negative numbers are encoded more efficiently in this data type, compared to `int32`.
  var x: [Int32] = []

  ///
  /// Direction value of one axis in µT/100, in the offset/diff format. E.g.:
  /// Absolute values: 67, -141, 42 => Offset-format: 67, -208, 183
  ///
  /// The offset/diff format encodes the data more efficiently, as the `varint` encoding is used.
  ///
  /// Absolute values between +- 4911.994 µT on Pixel 3a and +- 1300 µT on Tinkerforge are expected, i.e. +- 982_400 µT/100 diff.
  /// `32 bit` i.e. we support diffs up to ~2*10^9 µT/100 ~ 20 T so strong magnet as in the LHC/CERN are covered theoretically.
  ///
  /// The 10 nT (µT/100) unit does not cover you during travels between galaxies as you can't orientate by magnetic values
  /// due to the weak field there.
  ///
  /// Using `sint` as the one-axial-sensor-value can as likely decrease as increase - using the diff/offset format here.
  /// Negative numbers are encoded more efficiently in this data type, compared to `int32`.
  var y: [Int32] = []

  ///
  /// Direction value of one axis in µT/100, in the offset/diff format. E.g.:
  /// Absolute values: 67, -141, 42 => Offset-format: 67, -208, 183
  ///
  /// The offset/diff format encodes the data more efficiently, as the `varint` encoding is used.
  ///
  /// Absolute values between +- 4911.994 µT on Pixel 3a and +- 1300 µT on Tinkerforge are expected, i.e. +- 982_400 µT/100 diff.
  /// `32 bit` i.e. we support diffs up to ~2*10^9 µT/100 ~ 20 T so strong magnet as in the LHC/CERN are covered theoretically.
  ///
  /// The 10 nT (µT/100) unit does not cover you during travels between galaxies as you can't orientate by magnetic values
  /// due to the weak field there.
  ///
  /// Using `sint` as the one-axial-sensor-value can as likely decrease as increase - using the diff/offset format here.
  /// Negative numbers are encoded more efficiently in this data type, compared to `int32`.
  var z: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// A message type which wraps data of one event captured, such as the `start` lifecycle event or a `modality change`.
///
/// We store each event separately as we don't expect different event types to contain all fields.
/// Fields like `timestamp`, `type` and `value` use a 1 Byte field number (1-15) as this field probably occurs in most events.
///
/// If we do increase the frequency later on, we should also change the field number of `Measurement.events` to a 1 Byte number.
struct De_Cyface_Protos_Model_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// A Unix timestamp in milliseconds, as absolute values. E.g.: 1234567890123,1234567891123,...
  ///
  /// As we don't expect as many events as e.g. locations, we don't use the offset/diff variant here.
  ///
  /// Using `64bit` as the timestamp is absolute and in milliseconds since 1970 and, thus, not in the `integer` range.
  ///
  /// The value is encoded in the `uint` ProtoBuf format as we don't expect negative timestamps.
  /// Negative numbers are supported but encoded inefficiently in `uint` this data type, compared to `sint`.
  var timestamp: UInt64 = 0

  ///
  /// Type of the event captured which also helps to know which event fields to expect.
  var type: De_Cyface_Protos_Model_Event.EventType = .unspecified

  ///
  /// Additional information. Dependent on the `EventType`.
  ///
  /// E.g.: the new value after a `MODALITY_TYPE_CHANGE` such as `BICYCLE`.
  ///
  /// Protobuf `strings` must always contain UTF-8 encoded (or 7-bit ASCII text), and cannot be longer than 2^32.
  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// Enum which helps to identify different types of event and to know which event fields to expect.
  ///
  /// Reserving 1-15 for events which we might want to add later which occur very frequently
  ///
  /// Our current events like lifecycle-button-presses or modality-type-changes only occur rarely
  /// An example for high-frequent event types could be e.g. debugging/crash events
  ///
  /// For more details and options like "alias" see: https://developers.google.com/protocol-buffers/docs/proto3#enum
  enum EventType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///
    /// Default value.
    ///
    /// The 1st element of a proto enum must be 0. Following the Style Guide it's named enum_name_UNSPECIFIED.
    case unspecified // = 0

    ///
    /// Event captured when the user starts the data capturing (new `measurement`).
    case lifecycleStart // = 16

    ///
    /// Event captured when the user stops the data capturing (`measurement` finished).
    case lifecycleStop // = 17

    ///
    /// Event captured when the user resumes a paused `measurement`.
    case lifecycleResume // = 18

    ///
    /// Event captured when the user pauses a `measurement`.
    case lifecyclePause // = 19

    ///
    /// Event captured when the user changes the `modality` type, e.g. changes from FOOT to BICYCLE.
    case modalityTypeChange // = 20
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 16: self = .lifecycleStart
      case 17: self = .lifecycleStop
      case 18: self = .lifecycleResume
      case 19: self = .lifecyclePause
      case 20: self = .modalityTypeChange
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .lifecycleStart: return 16
      case .lifecycleStop: return 17
      case .lifecycleResume: return 18
      case .lifecyclePause: return 19
      case .modalityTypeChange: return 20
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension De_Cyface_Protos_Model_Event.EventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [De_Cyface_Protos_Model_Event.EventType] = [
    .unspecified,
    .lifecycleStart,
    .lifecycleStop,
    .lifecycleResume,
    .lifecyclePause,
    .modalityTypeChange,
  ]
}

#endif  // swift(>=4.2)

///
/// Message type which wraps a file which is collected during one measurement.
///
/// Reserving 1 Byte field numbers 1-15 for `repeated` complex type field which we might want to add later.
struct De_Cyface_Protos_Model_File {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// A Unix timestamp in milliseconds, as absolute values. E.g.: 1234567890123,1234567891123,...
  ///
  /// As we don't expect as many events as e.g. locations, we don't use the offset/diff variant here.
  ///
  /// Using `64bit` as the timestamp is absolute and in milliseconds since 1970 and, thus, not in the `integer` range.
  ///
  /// The value is encoded in the `uint` ProtoBuf format as we don't expect negative timestamps.
  /// Negative numbers are supported but encoded inefficiently in `uint` this data type, compared to `sint`.
  var timestamp: UInt64 = 0

  ///
  /// The type of the file represented by the binary data.
  var type: De_Cyface_Protos_Model_File.FileType = .unspecified

  ///
  /// The binary data of the file.
  ///
  /// "Any arbitrary sequence of bytes no longer than 2^32" https://developers.google.com/protocol-buffers/docs/proto3#scalar
  var bytes: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// The type of the file represented by the binary data.
  ///
  /// The 1st element must be 0. Following the Style Guide it's named enum_name_UNSPECIFIED.
  /// For more details and options like "alias" see: https://developers.google.com/protocol-buffers/docs/proto3#enum
  enum FileType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///
    /// Default value
    case unspecified // = 0

    ///
    /// Compressed image, interpreted as images captured during the measurement, e.g. from Android.
    case jpg // = 1

    ///
    /// Raw image, interpreted as images captured during the measurement, e.g. from Android.
    case dng // = 2

    ///
    /// Video, interpreted as a video captured during the measurement, e.g. from Android.
    case mp4 // = 3

    ///
    /// Log file used e.g. to protocol the image capturing rates on Android.
    case csv // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .jpg
      case 2: self = .dng
      case 3: self = .mp4
      case 4: self = .csv
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .jpg: return 1
      case .dng: return 2
      case .mp4: return 3
      case .csv: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension De_Cyface_Protos_Model_File.FileType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [De_Cyface_Protos_Model_File.FileType] = [
    .unspecified,
    .jpg,
    .dng,
    .mp4,
    .csv,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "de.cyface.protos.model"

extension De_Cyface_Protos_Model_Measurement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Measurement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    16: .standard(proto: "format_version"),
    17: .standard(proto: "location_records"),
    18: .standard(proto: "accelerations_binary"),
    19: .standard(proto: "rotations_binary"),
    20: .standard(proto: "directions_binary"),
    21: .same(proto: "events"),
    22: .same(proto: "images"),
    23: .same(proto: "videos"),
    24: .standard(proto: "capturing_log"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 16: try { try decoder.decodeSingularUInt32Field(value: &self.formatVersion) }()
      case 17: try { try decoder.decodeSingularMessageField(value: &self._locationRecords) }()
      case 18: try { try decoder.decodeSingularMessageField(value: &self._accelerationsBinary) }()
      case 19: try { try decoder.decodeSingularMessageField(value: &self._rotationsBinary) }()
      case 20: try { try decoder.decodeSingularMessageField(value: &self._directionsBinary) }()
      case 21: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 22: try { try decoder.decodeRepeatedMessageField(value: &self.images) }()
      case 23: try { try decoder.decodeRepeatedMessageField(value: &self.videos) }()
      case 24: try { try decoder.decodeSingularMessageField(value: &self._capturingLog) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.formatVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.formatVersion, fieldNumber: 16)
    }
    try { if let v = self._locationRecords {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    } }()
    try { if let v = self._accelerationsBinary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    } }()
    try { if let v = self._rotationsBinary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    } }()
    try { if let v = self._directionsBinary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    } }()
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 21)
    }
    if !self.images.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.images, fieldNumber: 22)
    }
    if !self.videos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.videos, fieldNumber: 23)
    }
    try { if let v = self._capturingLog {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: De_Cyface_Protos_Model_Measurement, rhs: De_Cyface_Protos_Model_Measurement) -> Bool {
    if lhs.formatVersion != rhs.formatVersion {return false}
    if lhs._locationRecords != rhs._locationRecords {return false}
    if lhs._accelerationsBinary != rhs._accelerationsBinary {return false}
    if lhs._rotationsBinary != rhs._rotationsBinary {return false}
    if lhs._directionsBinary != rhs._directionsBinary {return false}
    if lhs.events != rhs.events {return false}
    if lhs.images != rhs.images {return false}
    if lhs.videos != rhs.videos {return false}
    if lhs._capturingLog != rhs._capturingLog {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension De_Cyface_Protos_Model_MeasurementBytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MeasurementBytes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    16: .standard(proto: "format_version"),
    17: .standard(proto: "location_records"),
    18: .standard(proto: "accelerations_binary"),
    19: .standard(proto: "rotations_binary"),
    20: .standard(proto: "directions_binary"),
    21: .same(proto: "events"),
    22: .same(proto: "images"),
    23: .same(proto: "videos"),
    24: .standard(proto: "capturing_log"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 16: try { try decoder.decodeSingularUInt32Field(value: &self.formatVersion) }()
      case 17: try { try decoder.decodeSingularMessageField(value: &self._locationRecords) }()
      case 18: try { try decoder.decodeSingularBytesField(value: &self.accelerationsBinary) }()
      case 19: try { try decoder.decodeSingularBytesField(value: &self.rotationsBinary) }()
      case 20: try { try decoder.decodeSingularBytesField(value: &self.directionsBinary) }()
      case 21: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 22: try { try decoder.decodeRepeatedMessageField(value: &self.images) }()
      case 23: try { try decoder.decodeRepeatedMessageField(value: &self.videos) }()
      case 24: try { try decoder.decodeSingularMessageField(value: &self._capturingLog) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.formatVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.formatVersion, fieldNumber: 16)
    }
    try { if let v = self._locationRecords {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    } }()
    if !self.accelerationsBinary.isEmpty {
      try visitor.visitSingularBytesField(value: self.accelerationsBinary, fieldNumber: 18)
    }
    if !self.rotationsBinary.isEmpty {
      try visitor.visitSingularBytesField(value: self.rotationsBinary, fieldNumber: 19)
    }
    if !self.directionsBinary.isEmpty {
      try visitor.visitSingularBytesField(value: self.directionsBinary, fieldNumber: 20)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 21)
    }
    if !self.images.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.images, fieldNumber: 22)
    }
    if !self.videos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.videos, fieldNumber: 23)
    }
    try { if let v = self._capturingLog {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: De_Cyface_Protos_Model_MeasurementBytes, rhs: De_Cyface_Protos_Model_MeasurementBytes) -> Bool {
    if lhs.formatVersion != rhs.formatVersion {return false}
    if lhs._locationRecords != rhs._locationRecords {return false}
    if lhs.accelerationsBinary != rhs.accelerationsBinary {return false}
    if lhs.rotationsBinary != rhs.rotationsBinary {return false}
    if lhs.directionsBinary != rhs.directionsBinary {return false}
    if lhs.events != rhs.events {return false}
    if lhs.images != rhs.images {return false}
    if lhs.videos != rhs.videos {return false}
    if lhs._capturingLog != rhs._capturingLog {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension De_Cyface_Protos_Model_AccelerationsBinary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccelerationsBinary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accelerations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accelerations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accelerations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accelerations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: De_Cyface_Protos_Model_AccelerationsBinary, rhs: De_Cyface_Protos_Model_AccelerationsBinary) -> Bool {
    if lhs.accelerations != rhs.accelerations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension De_Cyface_Protos_Model_RotationsBinary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RotationsBinary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rotations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rotations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rotations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rotations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: De_Cyface_Protos_Model_RotationsBinary, rhs: De_Cyface_Protos_Model_RotationsBinary) -> Bool {
    if lhs.rotations != rhs.rotations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension De_Cyface_Protos_Model_DirectionsBinary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DirectionsBinary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "directions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.directions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.directions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.directions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: De_Cyface_Protos_Model_DirectionsBinary, rhs: De_Cyface_Protos_Model_DirectionsBinary) -> Bool {
    if lhs.directions != rhs.directions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension De_Cyface_Protos_Model_LocationRecords: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LocationRecords"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "latitude"),
    3: .same(proto: "longitude"),
    4: .same(proto: "elevation"),
    5: .same(proto: "accuracy"),
    6: .same(proto: "speed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeRepeatedSInt32Field(value: &self.latitude) }()
      case 3: try { try decoder.decodeRepeatedSInt32Field(value: &self.longitude) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.elevation) }()
      case 5: try { try decoder.decodeRepeatedSInt32Field(value: &self.accuracy) }()
      case 6: try { try decoder.decodeRepeatedSInt32Field(value: &self.speed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timestamp.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.latitude.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.latitude, fieldNumber: 2)
    }
    if !self.longitude.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.longitude, fieldNumber: 3)
    }
    if !self.elevation.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elevation, fieldNumber: 4)
    }
    if !self.accuracy.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.accuracy, fieldNumber: 5)
    }
    if !self.speed.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.speed, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: De_Cyface_Protos_Model_LocationRecords, rhs: De_Cyface_Protos_Model_LocationRecords) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.elevation != rhs.elevation {return false}
    if lhs.accuracy != rhs.accuracy {return false}
    if lhs.speed != rhs.speed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension De_Cyface_Protos_Model_LocationRecords.Elevation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = De_Cyface_Protos_Model_LocationRecords.protoMessageName + ".Elevation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "is_null"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularSInt32Field(value: &self.value) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isNull) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularSInt32Field(value: self.value, fieldNumber: 1)
    }
    if self.isNull != false {
      try visitor.visitSingularBoolField(value: self.isNull, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: De_Cyface_Protos_Model_LocationRecords.Elevation, rhs: De_Cyface_Protos_Model_LocationRecords.Elevation) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.isNull != rhs.isNull {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension De_Cyface_Protos_Model_Accelerations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Accelerations"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "x"),
    3: .same(proto: "y"),
    4: .same(proto: "z"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeRepeatedSInt32Field(value: &self.x) }()
      case 3: try { try decoder.decodeRepeatedSInt32Field(value: &self.y) }()
      case 4: try { try decoder.decodeRepeatedSInt32Field(value: &self.z) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timestamp.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.x.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.x, fieldNumber: 2)
    }
    if !self.y.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.y, fieldNumber: 3)
    }
    if !self.z.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.z, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: De_Cyface_Protos_Model_Accelerations, rhs: De_Cyface_Protos_Model_Accelerations) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension De_Cyface_Protos_Model_Rotations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Rotations"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "x"),
    3: .same(proto: "y"),
    4: .same(proto: "z"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeRepeatedSInt32Field(value: &self.x) }()
      case 3: try { try decoder.decodeRepeatedSInt32Field(value: &self.y) }()
      case 4: try { try decoder.decodeRepeatedSInt32Field(value: &self.z) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timestamp.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.x.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.x, fieldNumber: 2)
    }
    if !self.y.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.y, fieldNumber: 3)
    }
    if !self.z.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.z, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: De_Cyface_Protos_Model_Rotations, rhs: De_Cyface_Protos_Model_Rotations) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension De_Cyface_Protos_Model_Directions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Directions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "x"),
    3: .same(proto: "y"),
    4: .same(proto: "z"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeRepeatedSInt32Field(value: &self.x) }()
      case 3: try { try decoder.decodeRepeatedSInt32Field(value: &self.y) }()
      case 4: try { try decoder.decodeRepeatedSInt32Field(value: &self.z) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timestamp.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.x.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.x, fieldNumber: 2)
    }
    if !self.y.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.y, fieldNumber: 3)
    }
    if !self.z.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.z, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: De_Cyface_Protos_Model_Directions, rhs: De_Cyface_Protos_Model_Directions) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension De_Cyface_Protos_Model_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "type"),
    3: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: De_Cyface_Protos_Model_Event, rhs: De_Cyface_Protos_Model_Event) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.type != rhs.type {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension De_Cyface_Protos_Model_Event.EventType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EVENT_TYPE_UNSPECIFIED"),
    16: .same(proto: "LIFECYCLE_START"),
    17: .same(proto: "LIFECYCLE_STOP"),
    18: .same(proto: "LIFECYCLE_RESUME"),
    19: .same(proto: "LIFECYCLE_PAUSE"),
    20: .same(proto: "MODALITY_TYPE_CHANGE"),
  ]
}

extension De_Cyface_Protos_Model_File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".File"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    16: .same(proto: "timestamp"),
    17: .same(proto: "type"),
    18: .same(proto: "bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 16: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      case 17: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 18: try { try decoder.decodeSingularBytesField(value: &self.bytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 16)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 17)
    }
    if !self.bytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.bytes, fieldNumber: 18)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: De_Cyface_Protos_Model_File, rhs: De_Cyface_Protos_Model_File) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.type != rhs.type {return false}
    if lhs.bytes != rhs.bytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension De_Cyface_Protos_Model_File.FileType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FILE_TYPE_UNSPECIFIED"),
    1: .same(proto: "JPG"),
    2: .same(proto: "DNG"),
    3: .same(proto: "MP4"),
    4: .same(proto: "CSV"),
  ]
}
